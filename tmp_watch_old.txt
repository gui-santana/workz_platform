    // Faz polling do status do build tolerando erros transitórios (500) por um período
    async watchBuild(appId, attempts = 0, maxAttempts = 12, intervalMs = 1500) {
        try {
            const response = await this.getBuildStatusCompat(appId);
            if (response && response.success && response.data) {
                this.displayBuildStatusModal(response.data);
                const status = response.data.build_status;
                if (status === 'building' || status === 'pending') {
                    if (attempts < maxAttempts) {
                        const nextDelay = Math.min(10000, Math.round(intervalMs * Math.pow(1.5, attempts+1))); setTimeout(() => this.watchBuild(appId, attempts + 1, maxAttempts, nextDelay), nextDelay);
                    }
                }
                return;
            }
        } catch (_) {}
        // Em caso de erro (e.g., 500), continuar tentando enquanto dentro do limite
        if (attempts < maxAttempts) {
            const nextDelay = Math.min(10000, Math.round(intervalMs * Math.pow(1.5, attempts+1))); setTimeout(() => this.watchBuild(appId, attempts + 1, maxAttempts, nextDelay), nextDelay);
        } else {
            this.showToast('Não foi possível obter o status do build no momento.', 'error');
        }
    },
